<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gridstorm - Neon Dance</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      font-family: 'Courier New', monospace;
      overflow: hidden;
    }

    #logo {
      width: 64px;
      height: 64px;
      margin-bottom: 20px;
      opacity: 0.8;
      filter: drop-shadow(0 0 20px #c8ff00);
    }

    #startScreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.98);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    #startScreen.hidden {
      display: none;
    }

    #startTitle {
      font-size: 72px;
      font-weight: bold;
      color: #c8ff00;
      text-shadow: 0 0 30px #c8ff00;
      margin-bottom: 40px;
      letter-spacing: 8px;
    }

    #startButton {
      padding: 20px 60px;
      font-size: 24px;
      font-weight: bold;
      background: #c8ff00;
      color: #000;
      border: none;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 4px;
      box-shadow: 0 0 30px #c8ff00;
      transition: all 0.3s;
    }

    #startButton:hover {
      background: #00ffff;
      box-shadow: 0 0 50px #00ffff;
      transform: scale(1.05);
    }

    #gameContainer {
      position: relative;
      display: none;
    }

    #gameContainer.active {
      display: block;
    }

    canvas {
      border: 2px solid #c8ff00;
      border-radius: 4px;
      box-shadow: 0 0 40px #c8ff00, inset 0 0 20px rgba(200, 255, 0, 0.1);
      max-width: 100%;
      height: auto;
    }

    #hud {
      position: absolute;
      top: 12px;
      left: 12px;
      right: 12px;
      display: flex;
      justify-content: space-between;
      color: #c8ff00;
      font-size: 18px;
      text-shadow: 0 0 10px #c8ff00;
      pointer-events: none;
    }

    #gameOver {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.95);
      border: 3px solid #c8ff00;
      box-shadow: 0 0 60px #c8ff00;
      padding: 40px;
      text-align: center;
      border-radius: 8px;
      display: none;
    }

    #gameOver.active {
      display: block;
    }

    #gameOver h2 {
      font-size: 48px;
      color: #ff00ff;
      text-shadow: 0 0 20px #ff00ff;
      margin-bottom: 20px;
    }

    #gameOver p {
      font-size: 20px;
      color: #c8ff00;
      margin: 10px 0;
    }

    #restartButton {
      margin-top: 30px;
      padding: 15px 40px;
      font-size: 18px;
      font-weight: bold;
      background: #c8ff00;
      color: #000;
      border: none;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 3px;
      box-shadow: 0 0 20px #c8ff00;
      transition: all 0.3s;
    }

    #restartButton:hover {
      background: #00ffff;
      box-shadow: 0 0 40px #00ffff;
      transform: scale(1.05);
    }

    #controls {
      margin-top: 20px;
      color: #c8ff00;
      opacity: 0.6;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div id="startScreen">
    <img id="logo" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAATgAAAE4CAMAAAD4oR9YAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAACpQTFRFwP1cVG8pMD8XAAAAGCAMSF8jDBAGGCALMEAXeJ45bI80PFAdeJ46YH8uCZvTVgAAAeRJREFUeJzt3TluAzEQAEFZXkk+5P9/16GCBTZoGOCsUfUCopnxwFwuAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACrvV0HWx3nyPV9sNVxjggXCRcJFwkXCRcJFwkXCRcJFwkXCRcJFwkXCRcJFwkX7cNttzFWxzmyDzd6uXMIFwkXCRcJFwkXCRcJFwkXCRcJFwkXCRcJFwkXCRcJFwkXCRcJFwkXCRcJFwkXCRcJFwkXCRftw90fY0zew9HPvD5W1zkgXCRcJFwkXCRcJFwkXCRcJFwkXCRcJFwkXCRcJFwkXLQPd/1cZL+Uc4Vbdl59E64RLhIuEi4SLhIuEi4SLhIuEi4SLhIuEi4SLhIuEi4SLhIuEi4SLhIuEi4SLhIuEi4SLhIuEi46e7ht1VDQ+8nDDSJcJFwkXCRcJFwkXCRcJFwkXCRcJFwkXCRcJFwkXCRcNDnc1+pRoC/bqcINcq47h0GEi4SLhIuEi4SLhIuEi4SLhIuEi4SLhIuEi4SLhIuEi4SLhIuEi4SLhIuEi4SLhIuEi4SLzhXue/Uo0BffLv+McJFwkXCRcJFwkXCRcJFwkXCRcJFwkXCRcJFwkXCRcNHkcM+fwZ6r6wAAAAAAAAAAAAAAAAAAAAAAAAAAAADAf/ILRNW27H9IMzQAAAAASUVORK5CYII=" alt="Logo">
    <div id="startTitle">GRIDSTORM</div>
    <button id="startButton">Start Game</button>
  </div>

  <div id="gameContainer">
    <canvas id="canvas" width="800" height="600"></canvas>
    <div id="hud">
      <div>SCORE: <span id="score">0</span></div>
      <div>HIGH: <span id="highScore">0</span></div>
      <div>WAVE: <span id="wave">1</span></div>
    </div>
    <div id="gameOver">
      <h2>OVERLOAD</h2>
      <p>SCORE: <span id="finalScore">0</span></p>
      <p>HIGH: <span id="finalHighScore">0</span></p>
      <button id="restartButton">RESTART</button>
    </div>
    <div id="controls">WASD OR ARROW KEYS TO MOVE</div>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const startScreen = document.getElementById('startScreen');
    const gameContainer = document.getElementById('gameContainer');
    const startButton = document.getElementById('startButton');
    const restartButton = document.getElementById('restartButton');
    const gameOverDiv = document.getElementById('gameOver');

    let gameState = {
      playing: false,
      frameCount: 0,
      player: {
        x: 400,
        y: 300,
        size: 10,
        speed: 5,
        trail: []
      },
      patterns: [],
      keys: {},
      score: 0,
      highScore: parseInt(localStorage.getItem('gridstormHighScore') || '0'),
      wave: 1
    };

    document.getElementById('highScore').textContent = gameState.highScore;

    const colors = ['#c8ff00', '#00ffff', '#ff00ff', '#00ff88'];

    class Pattern {
      constructor(type, currentWave) {
        this.type = type;
        this.color = colors[Math.floor(Math.random() * colors.length)];
        this.speed = 2.5 + currentWave * 0.4;
        this.width = 35;
        this.life = 0;
        this.active = true;

        if (type === 'horizontal') {
          this.x = 0;
          this.y = Math.random() * canvas.height;
        } else if (type === 'vertical') {
          this.x = Math.random() * canvas.width;
          this.y = 0;
        } else if (type === 'diagonal') {
          this.x = Math.random() < 0.5 ? -100 : canvas.width + 100;
          this.y = Math.random() < 0.5 ? -100 : canvas.height + 100;
          this.angle = Math.random() * Math.PI * 2;
        } else if (type === 'pulse') {
          this.x = Math.random() * canvas.width;
          this.y = Math.random() * canvas.height;
          this.radius = 0;
          this.maxRadius = 180 + Math.random() * 80;
          this.speed = 2 + currentWave * 0.25;
          this.width = 25;
        }
      }

      update() {
        this.life++;

        if (this.type === 'horizontal') {
          this.y += this.speed;
          if (this.y > canvas.height + 100) this.active = false;
        } else if (this.type === 'vertical') {
          this.x += this.speed;
          if (this.x > canvas.width + 100) this.active = false;
        } else if (this.type === 'diagonal') {
          this.x += Math.cos(this.angle) * this.speed;
          this.y += Math.sin(this.angle) * this.speed;
          if (this.x < -200 || this.x > canvas.width + 200 || this.y < -200 || this.y > canvas.height + 200) {
            this.active = false;
          }
        } else if (this.type === 'pulse') {
          this.radius += this.speed;
          if (this.radius > this.maxRadius) this.active = false;
        }
      }

      draw() {
        ctx.shadowBlur = 25;
        ctx.shadowColor = this.color;

        if (this.type === 'horizontal') {
          const gradient = ctx.createLinearGradient(0, this.y - this.width / 2, 0, this.y + this.width / 2);
          gradient.addColorStop(0, 'rgba(0,0,0,0)');
          gradient.addColorStop(0.5, this.color);
          gradient.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = gradient;
          ctx.fillRect(0, this.y - this.width / 2, canvas.width, this.width);

          ctx.strokeStyle = this.color;
          ctx.lineWidth = 2;
          for (let i = 0; i < 5; i++) {
            ctx.beginPath();
            const x1 = Math.random() * canvas.width;
            const x2 = Math.random() * canvas.width;
            ctx.moveTo(x1, this.y - this.width / 2);
            for (let j = 1; j < 6; j++) {
              const t = j / 6;
              const x = x1 + (x2 - x1) * t + (Math.random() - 0.5) * 40;
              const y = this.y - this.width / 2 + this.width * t;
              ctx.lineTo(x, y);
            }
            ctx.stroke();
          }
        } else if (this.type === 'vertical') {
          const gradient = ctx.createLinearGradient(this.x - this.width / 2, 0, this.x + this.width / 2, 0);
          gradient.addColorStop(0, 'rgba(0,0,0,0)');
          gradient.addColorStop(0.5, this.color);
          gradient.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = gradient;
          ctx.fillRect(this.x - this.width / 2, 0, this.width, canvas.height);

          ctx.strokeStyle = this.color;
          ctx.lineWidth = 2;
          for (let i = 0; i < 5; i++) {
            ctx.beginPath();
            const y1 = Math.random() * canvas.height;
            const y2 = Math.random() * canvas.height;
            ctx.moveTo(this.x - this.width / 2, y1);
            for (let j = 1; j < 6; j++) {
              const t = j / 6;
              const y = y1 + (y2 - y1) * t + (Math.random() - 0.5) * 40;
              const x = this.x - this.width / 2 + this.width * t;
              ctx.lineTo(x, y);
            }
            ctx.stroke();
          }
        } else if (this.type === 'diagonal') {
          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.rotate(this.angle);
          const gradient = ctx.createLinearGradient(0, -this.width / 2, 0, this.width / 2);
          gradient.addColorStop(0, 'rgba(0,0,0,0)');
          gradient.addColorStop(0.5, this.color);
          gradient.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = gradient;
          ctx.fillRect(-500, -this.width / 2, 1000, this.width);
          ctx.restore();
        } else if (this.type === 'pulse') {
          const gradient = ctx.createRadialGradient(this.x, this.y, this.radius - this.width, this.x, this.y, this.radius);
          gradient.addColorStop(0, 'rgba(0,0,0,0)');
          gradient.addColorStop(0.5, this.color);
          gradient.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.strokeStyle = gradient;
          ctx.lineWidth = this.width;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.stroke();
        }

        ctx.shadowBlur = 0;
      }

      checkCollision(player) {
        if (this.type === 'horizontal') {
          return Math.abs(player.y - this.y) < this.width / 2 + player.size;
        } else if (this.type === 'vertical') {
          return Math.abs(player.x - this.x) < this.width / 2 + player.size;
        } else if (this.type === 'diagonal') {
          const dx = player.x - this.x;
          const dy = player.y - this.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist > 500) return false;
          const perpDist = Math.abs(-Math.sin(this.angle) * dx + Math.cos(this.angle) * dy);
          return perpDist < this.width / 2 + player.size;
        } else if (this.type === 'pulse') {
          const dx = player.x - this.x;
          const dy = player.y - this.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          return Math.abs(dist - this.radius) < this.width / 2 + player.size;
        }
        return false;
      }
    }

    window.addEventListener('keydown', (e) => {
      gameState.keys[e.key.toLowerCase()] = true;
    });

    window.addEventListener('keyup', (e) => {
      gameState.keys[e.key.toLowerCase()] = false;
    });

    function gameLoop() {
      if (!gameState.playing) return;

      gameState.frameCount++;
      gameState.score = Math.floor(gameState.frameCount / 2);
      gameState.wave = Math.floor(gameState.frameCount / 600) + 1;

      document.getElementById('score').textContent = gameState.score;
      document.getElementById('wave').textContent = gameState.wave;

      // Clear
      ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Grid
      ctx.strokeStyle = 'rgba(200, 255, 0, 0.08)';
      ctx.lineWidth = 1;
      const gridSize = 50;
      for (let x = 0; x < canvas.width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      for (let y = 0; y < canvas.height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }

      // Spawn patterns
      const spawnRate = Math.max(50 - gameState.wave * 3, 25);
      if (gameState.frameCount % spawnRate === 0) {
        const types = ['horizontal', 'vertical', 'diagonal', 'pulse'];
        const type = types[Math.floor(Math.random() * types.length)];
        gameState.patterns.push(new Pattern(type, gameState.wave));
      }

      // Update patterns
      gameState.patterns = gameState.patterns.filter(p => p.active);
      gameState.patterns.forEach(p => {
        p.update();
        p.draw();
        if (p.checkCollision(gameState.player)) {
          endGame();
        }
      });

      // Update player
      const player = gameState.player;
      if (gameState.keys['w'] || gameState.keys['arrowup']) player.y -= player.speed;
      if (gameState.keys['s'] || gameState.keys['arrowdown']) player.y += player.speed;
      if (gameState.keys['a'] || gameState.keys['arrowleft']) player.x -= player.speed;
      if (gameState.keys['d'] || gameState.keys['arrowright']) player.x += player.speed;

      player.x = Math.max(player.size, Math.min(canvas.width - player.size, player.x));
      player.y = Math.max(player.size, Math.min(canvas.height - player.size, player.y));

      player.trail.push({ x: player.x, y: player.y, life: 15 });
      player.trail = player.trail.filter(t => t.life-- > 0);

      // Draw trail
      player.trail.forEach(t => {
        const alpha = t.life / 15;
        ctx.fillStyle = `rgba(0, 255, 255, ${alpha * 0.6})`;
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#00ffff';
        ctx.beginPath();
        ctx.arc(t.x, t.y, player.size * alpha, 0, Math.PI * 2);
        ctx.fill();
      });

      // Draw player
      ctx.fillStyle = '#00ffff';
      ctx.shadowBlur = 25;
      ctx.shadowColor = '#00ffff';
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.size, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = '#ffffff';
      ctx.shadowBlur = 15;
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.size * 0.4, 0, Math.PI * 2);
      ctx.fill();

      ctx.shadowBlur = 0;

      requestAnimationFrame(gameLoop);
    }

    function startGame() {
      startScreen.classList.add('hidden');
      gameContainer.classList.add('active');
      gameState.playing = true;
      gameState.frameCount = 0;
      gameState.patterns = [];
      gameState.player.x = 400;
      gameState.player.y = 300;
      gameState.player.trail = [];
      gameState.score = 0;
      gameState.wave = 1;
      gameOverDiv.classList.remove('active');
      gameLoop();
    }

    function endGame() {
      gameState.playing = false;
      if (gameState.score > gameState.highScore) {
        gameState.highScore = gameState.score;
        localStorage.setItem('gridstormHighScore', gameState.highScore);
        document.getElementById('highScore').textContent = gameState.highScore;
      }
      document.getElementById('finalScore').textContent = gameState.score;
      document.getElementById('finalHighScore').textContent = gameState.highScore;
      gameOverDiv.classList.add('active');
    }

    startButton.addEventListener('click', startGame);
    restartButton.addEventListener('click', startGame);
  </script>
</body>
</html>
